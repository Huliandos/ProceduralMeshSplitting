using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CutterOG
{
    /// <summary>
    /// This class is the heart of mesh cutting, holding all it's operations and logic
    /// Logic inclues
    /// - Triangle sorting
    /// - Triangle splitting
    /// - Hole Filling
    /// - Mesh and GameObject creation
    /// - Mesh seperation
    /// </summary>

    //Variables hold reference to different Data of the mesh to cut for easy access accross the class
    GameObject gameObjectToCut;
    Mesh meshToCut;
    Material cutMaterial;
    bool cap;

    float timeSpend;
    int valueNumber;

    //Function that gets called from outer classes. Initializes all Variables and works through the procedure of Mesh cutting
    public void cut(GameObject gameObjectToCut, Vector3 contactPoint, Vector3 direction, Material cutMaterial = null, bool cap = true, bool concave=true, bool meshSeperation=false) {
        //Adapting plane normal to the new matrix generated by the local size of the gameObject to cut
        Vector3 localDirection = new Vector3(gameObjectToCut.transform.InverseTransformDirection(direction).x * gameObjectToCut.transform.localScale.x,
            gameObjectToCut.transform.InverseTransformDirection(direction).y,
            gameObjectToCut.transform.InverseTransformDirection(direction).z * gameObjectToCut.transform.localScale.z);

        Plane plane = new Plane(localDirection, gameObjectToCut.transform.InverseTransformDirection(contactPoint));

        this.gameObjectToCut = gameObjectToCut;
        meshToCut = gameObjectToCut.GetComponent<MeshFilter>().mesh;
        this.cutMaterial = cutMaterial;
        this.cap = cap;
        List<Vector3> addedVertices = new List<Vector3>();              //List of newly added vertices. It is used to cap the mesh later

        GeneratedMeshOG positiveSideMesh = new GeneratedMeshOG();
        GeneratedMeshOG negativeSideMesh = new GeneratedMeshOG();

        int[] submeshVertexIndices;
        int[] triangleVertexIndices = new int[3];

        float time = Time.realtimeSinceStartup;
        //parsing each submesh layer seperately
        for (int i = 0; i < meshToCut.subMeshCount; i++) {
            submeshVertexIndices = meshToCut.GetTriangles(i);

            //going through each Triangle within the submesh
            for (int j = 0; j < submeshVertexIndices.Length; j += 3) {
                for (int k = 0; k < 3; k++)
                    triangleVertexIndices[k] = submeshVertexIndices[j + k];

                MeshTriangleOG currentTriangle = getTriangle(triangleVertexIndices, i);

                bool[] isVertexPositiveSide = new bool[3];
                float[] distanceVertexToPlane = new float[3];   //this is used to also check if points are directly on plane, as get side returns false for point directly on plane

                //Triangle sorting
                isVertexPositiveSide[0] = plane.GetSide(meshToCut.vertices[triangleVertexIndices[0]]);
                distanceVertexToPlane[0] = Mathf.Abs(plane.GetDistanceToPoint(meshToCut.vertices[triangleVertexIndices[0]]));
                isVertexPositiveSide[1] = plane.GetSide(meshToCut.vertices[triangleVertexIndices[1]]);
                distanceVertexToPlane[1] = Mathf.Abs(plane.GetDistanceToPoint(meshToCut.vertices[triangleVertexIndices[1]]));
                isVertexPositiveSide[2] = plane.GetSide(meshToCut.vertices[triangleVertexIndices[2]]);
                distanceVertexToPlane[2] = Mathf.Abs(plane.GetDistanceToPoint(meshToCut.vertices[triangleVertexIndices[2]]));

                //0.0001, cause of potential rounding errors The calculated values range around e^-7
                //if ((isVertexPositiveSide[0] || distanceVertexToPlane[0]<=0.0001) && (isVertexPositiveSide[1] || distanceVertexToPlane[1] <= 0.0001) && (isVertexPositiveSide[2] || distanceVertexToPlane[2] <= 0.0001))
                if (isVertexPositiveSide[0] && isVertexPositiveSide[1] && isVertexPositiveSide[2])
                    positiveSideMesh.addTriangle(currentTriangle);
                else if (!isVertexPositiveSide[0] && !isVertexPositiveSide[1] && !isVertexPositiveSide[2])
                    negativeSideMesh.addTriangle(currentTriangle);
                else
                    cutTriangle(plane, currentTriangle, isVertexPositiveSide, positiveSideMesh, negativeSideMesh, addedVertices);
            }
        }

        if (cap) {
            fillCut(addedVertices, plane, positiveSideMesh, negativeSideMesh);
        }

        //Concave Meshes require special Operations like finding seperated Meshes, in case that they got cut into more than two pieces
        if (concave && meshSeperation)
        {
            findSeperatedMeshes(positiveSideMesh);
            findSeperatedMeshes(negativeSideMesh);
        }
        else
        {
            createGameObject(positiveSideMesh);
            createGameObject(negativeSideMesh);
        }

        //Destroy the root gameObject after cutting and object creation has been done
        GameObject.Destroy(gameObjectToCut);

        Debug.Log("Time spend: " + (Time.realtimeSinceStartup - time));
        //Debug.Log("average value: " + timeSpend/valueNumber);
    }

    //Function that turns an array of vertex indices into the corrosponding Mesh Triangle, populating it with its values
    MeshTriangleOG getTriangle(int[] triangleVertexIndices, int submeshIndex)
    {
        Vector3[] vertices = new Vector3[3];
        Vector3[] normals = new Vector3[3];
        Vector2[] uvs = new Vector2[3];

        for (int i = 0; i < 3; i++) {
            vertices[i] = meshToCut.vertices[triangleVertexIndices[i]];
            normals[i] = meshToCut.normals[triangleVertexIndices[i]];
            uvs[i] = meshToCut.uv[triangleVertexIndices[i]];
        }

        return new MeshTriangleOG(vertices, normals, uvs, submeshIndex);
    }

    //Function that cuts Triangles in three steps, sorting, calculating new position, UV and normals and then converting the calculated data in Mesh triangles
    void cutTriangle(Plane plane, MeshTriangleOG meshTriangle, bool[] isVertexPositiveSide, GeneratedMeshOG positiveSide, GeneratedMeshOG negativeSide, List<Vector3> addedVertices)
    {
        float time = Time.realtimeSinceStartup;

        //placeholder Triangles: max 2 Verteces per Side, so one side gets 2 unique verteces and the other one 2 equal ones
        MeshTriangleOG positiveSideMeshTriangle = new MeshTriangleOG(new Vector3[2], new Vector3[2], new Vector2[2], meshTriangle.getSubmeshIndex());
        MeshTriangleOG negativeSideMeshTriangle = new MeshTriangleOG(new Vector3[2], new Vector3[2], new Vector2[2], meshTriangle.getSubmeshIndex());

        bool positiveVertexExistent = false;
        bool negativeVertexExistent = false;

        #region sorting
        for (int i = 0; i < 3; i++)
        {
            if (isVertexPositiveSide[i])
            {
                if (!positiveVertexExistent)
                {
                    positiveVertexExistent = true;

                    positiveSideMeshTriangle.getVertices()[0] = meshTriangle.getVertices()[i];
                    positiveSideMeshTriangle.getVertices()[1] = positiveSideMeshTriangle.getVertices()[0];

                    positiveSideMeshTriangle.getNormals()[0] = meshTriangle.getNormals()[i];
                    positiveSideMeshTriangle.getNormals()[1] = positiveSideMeshTriangle.getNormals()[0];

                    positiveSideMeshTriangle.getUvs()[0] = meshTriangle.getUvs()[i];
                    positiveSideMeshTriangle.getUvs()[1] = positiveSideMeshTriangle.getUvs()[0];
                }
                else
                {
                    positiveSideMeshTriangle.getVertices()[1] = meshTriangle.getVertices()[i];
                    positiveSideMeshTriangle.getNormals()[1] = meshTriangle.getNormals()[i];
                    positiveSideMeshTriangle.getUvs()[1] = meshTriangle.getUvs()[i];
                }
            }
            else
            {
                if (!negativeVertexExistent)
                {
                    negativeVertexExistent = true;

                    negativeSideMeshTriangle.getVertices()[0] = meshTriangle.getVertices()[i];
                    negativeSideMeshTriangle.getVertices()[1] = negativeSideMeshTriangle.getVertices()[0];

                    negativeSideMeshTriangle.getNormals()[0] = meshTriangle.getNormals()[i];
                    negativeSideMeshTriangle.getNormals()[1] = negativeSideMeshTriangle.getNormals()[0];

                    negativeSideMeshTriangle.getUvs()[0] = meshTriangle.getUvs()[i];
                    negativeSideMeshTriangle.getUvs()[1] = negativeSideMeshTriangle.getUvs()[0];
                }
                else
                {
                    negativeSideMeshTriangle.getVertices()[1] = meshTriangle.getVertices()[i];
                    negativeSideMeshTriangle.getNormals()[1] = meshTriangle.getNormals()[i];
                    negativeSideMeshTriangle.getUvs()[1] = meshTriangle.getUvs()[i];
                }
            }
            
        }
        #endregion
        
        #region calculating position, UV and normals to add
        float distance, normalizedDistance;
        plane.Raycast(new Ray(positiveSideMeshTriangle.getVertices()[0], (negativeSideMeshTriangle.getVertices()[0] - positiveSideMeshTriangle.getVertices()[0]).normalized), out distance);
        
        normalizedDistance = distance / (negativeSideMeshTriangle.getVertices()[0] - positiveSideMeshTriangle.getVertices()[0]).magnitude;
        Vector3 vertexPositive = Vector3.Lerp(positiveSideMeshTriangle.getVertices()[0], negativeSideMeshTriangle.getVertices()[0], normalizedDistance);
        addedVertices.Add(vertexPositive);
        
        Vector3 normalPositive = Vector3.Lerp(positiveSideMeshTriangle.getNormals()[0], negativeSideMeshTriangle.getNormals()[0], normalizedDistance);
        Vector3 uvPositive = Vector2.Lerp(positiveSideMeshTriangle.getUvs()[0], negativeSideMeshTriangle.getUvs()[0], normalizedDistance);


        plane.Raycast(new Ray(positiveSideMeshTriangle.getVertices()[1], (negativeSideMeshTriangle.getVertices()[1] - positiveSideMeshTriangle.getVertices()[1]).normalized), out distance);

        normalizedDistance = distance / (negativeSideMeshTriangle.getVertices()[1] - positiveSideMeshTriangle.getVertices()[1]).magnitude;
        Vector3 vertexNegative = Vector3.Lerp(positiveSideMeshTriangle.getVertices()[1], negativeSideMeshTriangle.getVertices()[1], normalizedDistance);
        addedVertices.Add(vertexNegative);

        Vector3 normalNegative = Vector3.Lerp(positiveSideMeshTriangle.getNormals()[1], negativeSideMeshTriangle.getNormals()[1], normalizedDistance);
        Vector3 uvNegative = Vector2.Lerp(positiveSideMeshTriangle.getUvs()[1], negativeSideMeshTriangle.getUvs()[1], normalizedDistance);
        #endregion

        #region converting data to mesh triangles and adding it to the mesh if its not already part of it
        Vector3[] generatedVertices = new Vector3[] { positiveSideMeshTriangle.getVertices()[0], vertexPositive, vertexNegative };
        Vector3[] generatedNormals = new Vector3[] { positiveSideMeshTriangle.getNormals()[0], normalPositive, normalNegative };
        Vector2[] generatedUvs = new Vector2[] { positiveSideMeshTriangle.getUvs()[0], uvPositive, uvNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(positiveSide, generatedVertices, generatedNormals, generatedUvs, meshTriangle.getSubmeshIndex());

        generatedVertices = new Vector3[] { positiveSideMeshTriangle.getVertices()[0], positiveSideMeshTriangle.getVertices()[1], vertexNegative };
        generatedNormals = new Vector3[] { positiveSideMeshTriangle.getNormals()[0], positiveSideMeshTriangle.getNormals()[1], normalNegative };
        generatedUvs = new Vector2[] { positiveSideMeshTriangle.getUvs()[0], positiveSideMeshTriangle.getUvs()[1], uvNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(positiveSide, generatedVertices, generatedNormals, generatedUvs, meshTriangle.getSubmeshIndex());

        generatedVertices = new Vector3[] { negativeSideMeshTriangle.getVertices()[0], vertexPositive, vertexNegative };
        generatedNormals = new Vector3[] { negativeSideMeshTriangle.getNormals()[0], normalPositive, normalNegative };
        generatedUvs = new Vector2[] { negativeSideMeshTriangle.getUvs()[0], uvPositive, uvNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(negativeSide, generatedVertices, generatedNormals, generatedUvs, meshTriangle.getSubmeshIndex());

        generatedVertices = new Vector3[] { negativeSideMeshTriangle.getVertices()[0], negativeSideMeshTriangle.getVertices()[1], vertexNegative };
        generatedNormals = new Vector3[] { negativeSideMeshTriangle.getNormals()[0], negativeSideMeshTriangle.getNormals()[1], normalNegative };
        generatedUvs = new Vector2[] { negativeSideMeshTriangle.getUvs()[0], negativeSideMeshTriangle.getUvs()[1], uvNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(negativeSide, generatedVertices, generatedNormals, generatedUvs, meshTriangle.getSubmeshIndex());
        #endregion

        timeSpend += Time.realtimeSinceStartup - time;
        valueNumber++;
        //Debug.Log(Time.realtimeSinceStartup - time);

    }

    //Function that adds a triangle to the parsed in meshToAdd, while flipping it if it looks the wrong way
    void addGeneratedTriangle(GeneratedMeshOG meshToAdd, Vector3[] generatedVertices, Vector3[] generatedNormals, Vector2[] generatedUvs, int submeshIndex)
    {
        MeshTriangleOG generatedTriangle = new MeshTriangleOG(generatedVertices, generatedNormals, generatedUvs, submeshIndex);

        //Cross product = normal of two vertices, dot product
        //v * w > 0 == Vectors look at same side of plane || v * w < 0 == Vectors look at different of plane
        if (Vector3.Dot(Vector3.Cross(generatedVertices[1] - generatedVertices[0], generatedVertices[2] - generatedVertices[0]), generatedNormals[0]) < 0)
        {
            flipTriangle(generatedTriangle);
        }

        meshToAdd.addTriangle(generatedTriangle);
    }

    //Function switches the position of the first and last vertice, normal and uv with each other
    void flipTriangle(MeshTriangleOG meshTriangle)
    {
        List<Vector3> triangleVerticies = meshTriangle.getVertices();
        Vector3 lastVertex = triangleVerticies[triangleVerticies.Count-1];
        triangleVerticies[triangleVerticies.Count-1] = triangleVerticies[0];
        triangleVerticies[0] = lastVertex;


        List<Vector3> triangleNormals = meshTriangle.getNormals();
        Vector3 lastNormal = triangleNormals[triangleNormals.Count-1];
        triangleNormals[triangleNormals.Count-1] = triangleNormals[0];
        triangleNormals[0] = lastNormal;


        List<Vector2> triangleUvs = meshTriangle.getUvs();
        Vector2 lastUV = triangleUvs[triangleUvs.Count-1];
        triangleUvs[triangleUvs.Count-1] = triangleUvs[0];
        triangleUvs[0] = lastUV;
    }

    #region Capping
    //Function that creates polygones out of all cut vertices using a helper function and then parses these polygons into the actual fill function
    void fillCut(List<Vector3> addedVertices, Plane plane, GeneratedMeshOG positiveMesh, GeneratedMeshOG negativeMesh) {
        List<Vector3> processedVertices = new List<Vector3>(), polygone = new List<Vector3>();

        for (int i=0; i<addedVertices.Count-1; i++) {           //-1 Custom Edit, trying to prevent OFB excepton
            if (!processedVertices.Contains(addedVertices[i])) {
                polygone = new List<Vector3>();
                polygone.Add(addedVertices[i]);
                polygone.Add(addedVertices[i+1]);          //OUT OF BOUNDS EXCEPTION here sometimes

                processedVertices.Add(addedVertices[i]);
                processedVertices.Add(addedVertices[i+1]);

                findConnectedVertices(addedVertices, processedVertices, polygone);
                fill(polygone, plane, positiveMesh, negativeMesh);
            }
        }
    }

    //Function that connects parsed in vertices by finding their middle point (like with an Orange). It then addes those newly created vertices to both sides of the cut Mesh
    void fill(List<Vector3> vertices, Plane plane, GeneratedMeshOG positiveMesh, GeneratedMeshOG negativeMesh)
    {
        //finding the center
        Vector3 center = new Vector3();
        for (int i = 0; i < vertices.Count; i++) {
            center += vertices[i];
        }
        center /= vertices.Count;
        
        Vector3 up = plane.normal;
        Vector3 left = new Vector3 (-up.y, up.x, 0);
        Vector3 forward = Quaternion.AngleAxis(90, up) * left;
        
        Vector3 displacement = new Vector3();
        Vector2 uv1, uv2;

        for (int i = 0; i < vertices.Count; i++) {
            displacement = vertices[i] - center;
            uv1 = new Vector2(.5f + Vector3.Dot(displacement, left), .5f + Vector3.Dot(displacement, forward));

            //Debug.Log("vertex: " + vertices[i] + " displacement: " + displacement + " dot product left: " + Vector3.Dot(displacement, left) + " dot product forward: " + Vector3.Dot(displacement, forward));

            displacement = vertices[(i+1)%vertices.Count] - center;
            uv2 = new Vector2(.5f + Vector3.Dot(displacement, left), .5f + Vector3.Dot(displacement, forward));

            Vector3[] generatedVertices = new Vector3[] {vertices[i], vertices[(i+1)%vertices.Count], center};
            Vector3[] generatedNormals = new Vector3[] {-up, -up, -up};
            Vector2[] generatedUvs = new Vector2[] { uv1, uv2, new Vector2(0.5f, 0.5f)}; 

            //don't create different submesh layer if cutMaterial isn't set
            int submeshIndex = 0;

            //create it if it isn't
            if (cutMaterial != null)
            {
                if (!doesIncludeMaterial(gameObjectToCut.GetComponent<Renderer>().materials, cutMaterial))
                    submeshIndex = meshToCut.subMeshCount;
                else {
                    for (int j=0; j<gameObjectToCut.GetComponent<Renderer>().materials.Length; j++) {
                        if (compareMaterialNames(gameObjectToCut.GetComponent<Renderer>().materials[j], cutMaterial))
                            submeshIndex = j;
                    }
                }
            }

            addGeneratedTriangle(positiveMesh, generatedVertices, generatedNormals, generatedUvs, submeshIndex);

            generatedNormals = new Vector3[] {up, up, up};
            addGeneratedTriangle(negativeMesh, generatedVertices, generatedNormals, generatedUvs, submeshIndex);
        }
    }

    //Function that creates polygones out of all cut vertices
    void findConnectedVertices(List<Vector3> addedVertices, List<Vector3> processedVertices, List<Vector3> polygone)
    {
        bool isDone = false;
        while (!isDone) {
            isDone = true;
            for (int i=0; i<addedVertices.Count; i+=2) {
                if (addedVertices[i] == polygone[polygone.Count-1] && !processedVertices.Contains(addedVertices[i+1]))
                {
                    isDone = false;
                    polygone.Add(addedVertices[i+1]);
                    processedVertices.Add(addedVertices[i+1]);
                }
                else if (addedVertices[i+1] == polygone[polygone.Count-1] && !processedVertices.Contains(addedVertices[i])) {
                    isDone = false;
                    polygone.Add(addedVertices[i]);
                    processedVertices.Add(addedVertices[i]);
                }
            }
        }
    }
    #endregion

    #region Mesh creation
    //Function that creates interactable gameObjects within the scene using the root Objects Data and the generated mesh data
    void createGameObject(GeneratedMeshOG newMeshData)
    {
        //if the colliders of a Mesh are bigger than the Mesh itself, so the Function was triggered but no triangle was cut
        if (newMeshData.getVertices().Count > 0)
        {
            //creating copy of the game Object that is getting cut
            GameObject cutGameObject = GameObject.Instantiate(gameObjectToCut, gameObjectToCut.transform.position, gameObjectToCut.transform.rotation);
            //only if a cutObjectContainer exists (like in the testing scene)
            if (GameObject.FindGameObjectWithTag(Tags.cutObjectContainer))
                cutGameObject.transform.SetParent(GameObject.FindGameObjectWithTag(Tags.cutObjectContainer).transform);
            else
                cutGameObject.transform.SetParent(gameObjectToCut.transform.parent);

            Mesh generatedMesh = cutGameObject.GetComponent<MeshFilter>().mesh;
            generatedMesh.Clear();

            //set new materials Array when a cut Material is to be added
            if (cutMaterial != null && cap) {
                Material[] materials;
                //adds cut Material to submesh layers if it isn't already part of it while copying all Materials that are part of the Mesh
                if (!doesIncludeMaterial(gameObjectToCut.GetComponent<Renderer>().materials, cutMaterial))
                {
                    generatedMesh.subMeshCount = meshToCut.subMeshCount + 1;

                    materials = new Material[cutGameObject.GetComponent<Renderer>().materials.Length + 1];

                    materials[materials.Length - 1] = cutMaterial;
                }
                //copies all Materials that are part of the Mesh
                else
                {
                    generatedMesh.subMeshCount = meshToCut.subMeshCount;

                    materials = new Material[cutGameObject.GetComponent<Renderer>().materials.Length];
                }
                for (int i = 0; i < cutGameObject.GetComponent<Renderer>().materials.Length; i++) {
                    materials[i] = cutGameObject.GetComponent<Renderer>().materials[i];
                }

                cutGameObject.GetComponent<Renderer>().materials = materials;
            }

            //writes all mesh Data into the mesh
            generatedMesh.vertices = newMeshData.getVertices().ToArray();
            generatedMesh.normals = newMeshData.getNormals().ToArray();
            generatedMesh.SetUVs(0, newMeshData.getUvs());
            for (int i = 0; i < newMeshData.getSubmeshIndices().Count; i++)
            {
                generatedMesh.SetTriangles(newMeshData.getSubmeshIndices()[i].ToArray(), i);
            }

            foreach (Collider col in cutGameObject.GetComponents<Collider>())
                GameObject.Destroy(col);
            
            //creates mesh Collider for Object
            MeshCollider meshCollider = cutGameObject.AddComponent<MeshCollider>();
            meshCollider.convex = true;
            meshCollider.sharedMesh = cutGameObject.GetComponent<MeshFilter>().mesh;
        }
    }

    //Function that finds seperated Meshes within one GeneratedMesh and initializes them all seperately
    void findSeperatedMeshes(GeneratedMeshOG meshToSeperate)
    {
        List<int> connectedVertexIndeces, leftoverVertexIndeces = new List<int>();

        int numberOfVertexIndeces = 0;

        foreach (List<int> vertexIndeces in meshToSeperate.getSubmeshIndices())
        {
            leftoverVertexIndeces.AddRange(vertexIndeces);
            numberOfVertexIndeces += vertexIndeces.Count;
        }
        
        while (leftoverVertexIndeces.Count > 0) {
            connectedVertexIndeces = new List<int>();
            int[] currentTriangle = new int[] { leftoverVertexIndeces[0], leftoverVertexIndeces[1], leftoverVertexIndeces[2]};

            leftoverVertexIndeces.RemoveRange(0, 3);

            //holds all Vertex Indeces that are connected with one another
            connectedVertexIndeces = getConnectedTriangles(currentTriangle, leftoverVertexIndeces, meshToSeperate);

            //if there's no seperation
            if (connectedVertexIndeces.Count == numberOfVertexIndeces)
            {
                createGameObject(meshToSeperate);
                break;
            }
            else
            {
                GeneratedMeshOG seperatedMesh = new GeneratedMeshOG();

                for (int i = 0; i < connectedVertexIndeces.Count; i += 3)
                {
                    //uses data in connectedVertexIndeces to copy all Mesh data into a new GeneratedMesh
                    Vector3[] vertices = new Vector3[3] {meshToSeperate.getVertices()[connectedVertexIndeces[i]],
                        meshToSeperate.getVertices()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getVertices()[connectedVertexIndeces[i+2]]};
                    Vector3[] normals = new Vector3[3] {meshToSeperate.getNormals()[connectedVertexIndeces[i]],
                        meshToSeperate.getNormals()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getNormals()[connectedVertexIndeces[i+2]]};
                    Vector2[] Uvs = new Vector2[3] {meshToSeperate.getUvs()[connectedVertexIndeces[i]],
                        meshToSeperate.getUvs()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getUvs()[connectedVertexIndeces[i+2]]};

                    int submeshIndex = 0;
                    if (meshToSeperate.getSubmeshIndices().Count > 1) {
                        //Parses all submeshes of mesh until it finds the one holding our verteces
                        for (int j = 0; j < meshToSeperate.getSubmeshIndices().Count; j++) {
                            if (meshToSeperate.getSubmeshIndices()[j].Contains(connectedVertexIndeces[i]) &&
                                meshToSeperate.getSubmeshIndices()[j].Contains(connectedVertexIndeces[i+1]) &&
                                meshToSeperate.getSubmeshIndices()[j].Contains(connectedVertexIndeces[i+2]))
                            {
                                submeshIndex = j;
                                break;
                            }
                        }
                    }

                    MeshTriangleOG meshTriangle = new MeshTriangleOG(vertices, normals, Uvs, submeshIndex);

                    seperatedMesh.addTriangle(meshTriangle);

                    leftoverVertexIndeces.Remove(connectedVertexIndeces[i]);
                    leftoverVertexIndeces.Remove(connectedVertexIndeces[i+1]);
                    leftoverVertexIndeces.Remove(connectedVertexIndeces[i+2]);
                }

                createGameObject(seperatedMesh);
            }
        }
    }

    //Function that finds all connected vertex Indeces recursively for a picked Triangle
    public List<int> getConnectedTriangles(int[] pickedTriangle, List<int> vertexIndeces, GeneratedMeshOG meshToSeperate)
    {
        List<int> result = new List<int>(pickedTriangle), neighbors = new List<int>(), indecesOfIndecesToRemove = new List<int>();

        // Finding all neigbor Triangles
        for (int i = 0; i < vertexIndeces.Count; i += 3)
        {
            int[] currentTriangle = new int[3] {vertexIndeces[i], vertexIndeces[i + 1], vertexIndeces[i + 2]};
            
            // Check if Triangles share common Edge
            if (isConnected(convertIndecesToVerteces(currentTriangle, meshToSeperate), convertIndecesToVerteces(pickedTriangle, meshToSeperate)))
            {
                neighbors.AddRange(currentTriangle);

                indecesOfIndecesToRemove.Add(i);
                indecesOfIndecesToRemove.Add(i+1);
                indecesOfIndecesToRemove.Add(i+2);

                //performance boost: cancel this operation when neighbors length is 3 in first call and 2 in every single other call
            }
        }

        //remove all already connected Trinagles out of the vertexIndeces List
        for (int i = indecesOfIndecesToRemove.Count-1; i >= 0; i--)
        {
            vertexIndeces.RemoveAt(indecesOfIndecesToRemove[i]);
        }

        //recall this function recursively to find all existing neighbors
        for (int i = 0; i < neighbors.Count; i += 3)
        {
            int[] currentTriangle = new int[3] { neighbors[i], neighbors[i + 1], neighbors[i + 2] };
            
            // Recursively add all the linked faces to the result
            result.AddRange(getConnectedTriangles(currentTriangle, vertexIndeces, meshToSeperate));
        }
        
        return result;
    }
    
    //Function that checks if the Edges of two Verteces are similar to one another
    bool isConnected(Vector3[] triangleA, Vector3[] triangleB)
    {
        for (int i = 0; i < triangleA.Length; i++)
            for (int j = 0; j < triangleB.Length; j++)
                if (triangleA[i] == triangleB[j] &&
                    ((triangleA[(i + 1) % 3] == triangleB[(j + 1) % 3] || triangleA[(i + 1) % 3] == triangleB[(j + 2) % 3]) ||
                    (triangleA[(i + 2) % 3] == triangleB[(j + 1) % 3] || triangleA[(i + 2) % 3] == triangleB[(j + 2) % 3])))
                    return true;

        return false;
    }
    
    //Function that converts vertex Indeces into their respective Vertex
    Vector3[] convertIndecesToVerteces(int[] vertexIndices, GeneratedMeshOG meshData)
    {
        Vector3[] vecs = new Vector3[vertexIndices.Length];

        for (int i = 0; i < vecs.Length; i++) {
            vecs[i] = meshData.getVertices()[vertexIndices[i]];
        }

        return vecs;
    }

    //returns if list of material Instances does include root material
    bool doesIncludeMaterial(Material[] materials, Material material) {
        foreach (Material mat in materials)
        {
            if (compareMaterialNames(mat, material))
                return true;
        }

        return false;
    }

    //checking if names are similar and then again by removing excess name on both sides: E.g. (Instance) tag
    bool compareMaterialNames(Material materialA, Material materialB)
    {
        if (materialA.name == materialB.name)
            return true;
        
        if (materialA.name.Length > materialB.name.Length && materialA.name.Substring(0, materialB.name.Length) == materialB.name)
            return true;
        
        if (materialA.name.Length < materialB.name.Length && materialB.name.Substring(0, materialA.name.Length) == materialA.name)
            return true;

        return false;
    }
    #endregion
}
