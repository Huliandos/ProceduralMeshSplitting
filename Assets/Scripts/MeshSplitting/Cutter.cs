using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Threading;

public class Cutter
{
    /// <summary>
    /// This class is the heart of mesh cutting, holding all it's operations and logic
    /// Logic inclues
    /// - Triangle sorting
    /// - Triangle splitting
    /// - Hole Filling
    /// - Mesh and GameObject creation
    /// - Mesh seperation
    /// </summary>

    //Variables hold reference to different Data of the mesh to cut for easy access accross the class
    GameObject gameObjectToCut;
    Mesh meshToCut;
    Material cutMaterial;
    bool cap;

    //multi threading
    object lockGeneratedMesh = new object();

    float timeSpend;
    int valueNumber;

    //Function that gets called from outer classes. Initializes all Variables and works through the procedure of Mesh cutting
    public void cut(GameObject gameObjectToCut, Vector3 contactPoint, Vector3 direction, Material cutMaterial = null, bool cap = true, bool concave=true, bool meshSeperation=false) {
        //Adapting plane normal to the new matrix generated by the local size of the gameObject to cut
        Vector3 localDirection = new Vector3(gameObjectToCut.transform.InverseTransformDirection(direction).x * gameObjectToCut.transform.localScale.x,
            gameObjectToCut.transform.InverseTransformDirection(direction).y * gameObjectToCut.transform.localScale.y,   //idea to fix scaling problem
            gameObjectToCut.transform.InverseTransformDirection(direction).z * gameObjectToCut.transform.localScale.z);

        Plane plane = new Plane(localDirection, gameObjectToCut.transform.InverseTransformDirection(contactPoint));

        this.gameObjectToCut = gameObjectToCut;
        meshToCut = gameObjectToCut.GetComponent<MeshFilter>().mesh;
        //meshToCut.MarkDynamic();                                        //--> Experimental. Does this improve cutter performance
        this.cutMaterial = cutMaterial;
        this.cap = cap;
        List<Vector3> addedVertices = new List<Vector3>();              //List of newly added vertices. It is used to cap the mesh later

        GeneratedMesh positiveSideMesh = new GeneratedMesh();
        GeneratedMesh negativeSideMesh = new GeneratedMesh();

        GeneratedMesh testMesh = new GeneratedMesh();

        int[] submeshVertexIndices;
        Vector3[] meshVertices = meshToCut.vertices; 
        Vector3[] meshNormals = meshToCut.normals; 
        Vector2[] meshUvs = meshToCut.uv;
        Vector2[] meshRtLightmapUvs = meshToCut.uv2; //this are the global ilumination map UVs

        testMesh.setVertices(meshVertices.ToList());
        testMesh.setNormals(meshNormals.ToList());
        testMesh.setUvs( meshUvs.ToList());
        testMesh.setRtLightmapUvs(meshRtLightmapUvs.ToList());

        createGameObject(testMesh);

        List<Thread> threads = new List<Thread>();

        float time = Time.realtimeSinceStartup;
        //parsing each submesh layer seperately

        for (int i = 0; i < meshToCut.subMeshCount; i++)
        {
            submeshVertexIndices = meshToCut.GetTriangles(i);

            //going through each Triangle within the submesh
            ///ToDo: Each Triangle is processed by a single Thread
            for (int j = 0; j < submeshVertexIndices.Length; j += 3)
            {
                int startTriangleIndex = j; // these two lines of code are here, to prevent an error, where all variables get accessed like reference type variables in C# Multi THreading
                int submeshIndex = i;
                Thread thread = new Thread(() => sortTriangle(submeshVertexIndices, startTriangleIndex, submeshIndex, plane, addedVertices, positiveSideMesh, negativeSideMesh
                    , meshVertices, meshNormals, meshUvs, meshRtLightmapUvs));
                threads.Add(thread);
                thread.Start();

                //sortTriangle(submeshVertexIndices, j, i, plane, addedVertices, positiveSideMesh, negativeSideMesh
                //    , meshVertices, meshNormals, meshUvs, meshRtLightmapUvs);
            }
        }

        foreach (Thread thread in threads) thread.Join();

        if (cap) {
            fillCut(addedVertices, plane, positiveSideMesh, negativeSideMesh);
        }

        //Concave Meshes require special Operations like finding seperated Meshes, in case that they got cut into more than two pieces
        if (concave && meshSeperation)
        {
            findSeperatedMeshes(positiveSideMesh);
            findSeperatedMeshes(negativeSideMesh);
        }
        else
        {
            createGameObject(positiveSideMesh);
            createGameObject(negativeSideMesh);
        }

        //Destroy the root gameObject after cutting and object creation has been done
        GameObject.Destroy(gameObjectToCut);

        //float time = Time.realtimeSinceStartup;
        //timeSpend += Time.realtimeSinceStartup - time;
        //valueNumber++;
        Debug.Log("Time spend: " + (Time.realtimeSinceStartup - time));
        //Debug.Log("average value: " + timeSpend/valueNumber);
    }

    //Multithread vertex sorting
    void sortTriangle(int[] submeshVertexIndices, int startTriangleIndex, int submeshIndex, Plane plane, List<Vector3> addedVertices,
        GeneratedMesh positiveSideMesh, GeneratedMesh negativeSideMesh, Vector3[] meshVertices, Vector3[] meshNormals, Vector2[] meshUvs, Vector2[] meshRtLightmapUvs)
    {
        int[] triangleVertexIndices = new int[3];

        for (int k = 0; k < 3; k++)
            triangleVertexIndices[k] = submeshVertexIndices[startTriangleIndex+k];

        //get current Triangle
        //MeshTriangle currentTriangle = getTriangle(triangleVertexIndices, submeshIndex, meshToCut);
        Vector3[] vertices = new Vector3[3];
        Vector3[] normals = new Vector3[3];
        Vector2[] uvs = new Vector2[3];
        Vector2[] rtLightmapUvs = new Vector2[3];

        for (int i = 0; i < 3; i++)
        {
            vertices[i] = meshVertices[triangleVertexIndices[i]];
            normals[i] = meshNormals[triangleVertexIndices[i]];
            uvs[i] = meshUvs[triangleVertexIndices[i]];
            if(meshRtLightmapUvs.Length > 0)
                rtLightmapUvs[i] = meshRtLightmapUvs[triangleVertexIndices[i]];
            else
                rtLightmapUvs[i] = new Vector2(0, 0);               //--> Quickfix. Todo: Fix properly later
        }

        MeshTriangle currentTriangle = new MeshTriangle(vertices, normals, uvs, rtLightmapUvs, submeshIndex);

        bool[] isVertexPositiveSide = new bool[3];
        //float[] distanceVertexToPlane = new float[3];   //this is used to also check if points are directly on plane, as get side returns false for point directly on plane

        //Triangle sorting
        isVertexPositiveSide[0] = plane.GetSide(meshVertices[triangleVertexIndices[0]]);
        //distanceVertexToPlane[0] = Mathf.Abs(plane.GetDistanceToPoint(meshVertices[triangleVertexIndices[0]]));
        isVertexPositiveSide[1] = plane.GetSide(meshVertices[triangleVertexIndices[1]]);
        //distanceVertexToPlane[1] = Mathf.Abs(plane.GetDistanceToPoint(meshVertices[triangleVertexIndices[1]]));
        isVertexPositiveSide[2] = plane.GetSide(meshVertices[triangleVertexIndices[2]]);
        //distanceVertexToPlane[2] = Mathf.Abs(plane.GetDistanceToPoint(meshVertices[triangleVertexIndices[2]]));

        lock (lockGeneratedMesh)
        {
            if (isVertexPositiveSide[0] && isVertexPositiveSide[1] && isVertexPositiveSide[2])
                positiveSideMesh.addTriangle(currentTriangle);
            else if (!isVertexPositiveSide[0] && !isVertexPositiveSide[1] && !isVertexPositiveSide[2])
                negativeSideMesh.addTriangle(currentTriangle);
            else
                cutTriangle(plane, currentTriangle, isVertexPositiveSide, positiveSideMesh, negativeSideMesh, addedVertices);
        }
    }

    //Function that turns an array of vertex indices into the corrosponding Mesh Triangle, populating it with its values
    MeshTriangle getTriangle(int[] triangleVertexIndices, int submeshIndex, Mesh meshToCut)
    {
        Vector3[] vertices = new Vector3[3];
        Vector3[] normals = new Vector3[3];
        Vector2[] uvs = new Vector2[3];
        Vector2[] rtLightmapUvs = new Vector2[3];

        for (int i = 0; i < 3; i++) {
            vertices[i] = meshToCut.vertices[triangleVertexIndices[i]];
            normals[i] = meshToCut.normals[triangleVertexIndices[i]];
            uvs[i] = meshToCut.uv[triangleVertexIndices[i]];
            rtLightmapUvs[i] = meshToCut.uv2[triangleVertexIndices[i]];
        }

        return new MeshTriangle(vertices, normals, uvs, rtLightmapUvs, submeshIndex);
    }

    //Function that cuts Triangles in three steps, sorting, calculating new position, UV and normals and then converting the calculated data in Mesh triangles
    void cutTriangle(Plane plane, MeshTriangle meshTriangle, bool[] isVertexPositiveSide, GeneratedMesh positiveSide, GeneratedMesh negativeSide, List<Vector3> addedVertices)
    {
        //placeholder Triangles: max 2 Verteces per Side, so one side gets 2 unique verteces and the other one 2 equal ones
        MeshTriangle positiveSideMeshTriangle = new MeshTriangle(new Vector3[2], new Vector3[2], new Vector2[2], new Vector2[2], meshTriangle.getSubmeshIndex());
        MeshTriangle negativeSideMeshTriangle = new MeshTriangle(new Vector3[2], new Vector3[2], new Vector2[2], new Vector2[2], meshTriangle.getSubmeshIndex());

        bool positiveVertexExistent = false;
        bool negativeVertexExistent = false;

        #region sorting
        for (int i = 0; i < 3; i++)
        {
            if (isVertexPositiveSide[i])
            {
                if (!positiveVertexExistent)
                {
                    positiveVertexExistent = true;

                    positiveSideMeshTriangle.getVertices()[0] = meshTriangle.getVertices()[i];
                    positiveSideMeshTriangle.getVertices()[1] = positiveSideMeshTriangle.getVertices()[0];

                    positiveSideMeshTriangle.getNormals()[0] = meshTriangle.getNormals()[i];
                    positiveSideMeshTriangle.getNormals()[1] = positiveSideMeshTriangle.getNormals()[0];

                    positiveSideMeshTriangle.getUvs()[0] = meshTriangle.getUvs()[i];
                    positiveSideMeshTriangle.getUvs()[1] = positiveSideMeshTriangle.getUvs()[0];

                    positiveSideMeshTriangle.getRtLightmapUvs()[0] = meshTriangle.getRtLightmapUvs()[i];
                    positiveSideMeshTriangle.getRtLightmapUvs()[1] = positiveSideMeshTriangle.getRtLightmapUvs()[0];
                }
                else
                {
                    positiveSideMeshTriangle.getVertices()[1] = meshTriangle.getVertices()[i];
                    positiveSideMeshTriangle.getNormals()[1] = meshTriangle.getNormals()[i];
                    positiveSideMeshTriangle.getUvs()[1] = meshTriangle.getUvs()[i];
                    positiveSideMeshTriangle.getRtLightmapUvs()[1] = meshTriangle.getRtLightmapUvs()[i];
                }
            }
            else
            {
                if (!negativeVertexExistent)
                {
                    negativeVertexExistent = true;

                    negativeSideMeshTriangle.getVertices()[0] = meshTriangle.getVertices()[i];
                    negativeSideMeshTriangle.getVertices()[1] = negativeSideMeshTriangle.getVertices()[0];

                    negativeSideMeshTriangle.getNormals()[0] = meshTriangle.getNormals()[i];
                    negativeSideMeshTriangle.getNormals()[1] = negativeSideMeshTriangle.getNormals()[0];

                    negativeSideMeshTriangle.getUvs()[0] = meshTriangle.getUvs()[i];
                    negativeSideMeshTriangle.getUvs()[1] = negativeSideMeshTriangle.getUvs()[0];

                    negativeSideMeshTriangle.getRtLightmapUvs()[0] = meshTriangle.getRtLightmapUvs()[i];
                    negativeSideMeshTriangle.getRtLightmapUvs()[1] = negativeSideMeshTriangle.getRtLightmapUvs()[0];
                }
                else
                {
                    negativeSideMeshTriangle.getVertices()[1] = meshTriangle.getVertices()[i];
                    negativeSideMeshTriangle.getNormals()[1] = meshTriangle.getNormals()[i];
                    negativeSideMeshTriangle.getUvs()[1] = meshTriangle.getUvs()[i];
                    negativeSideMeshTriangle.getRtLightmapUvs()[1] = meshTriangle.getRtLightmapUvs()[i];
                }
            }
            
        }
        #endregion
        
        #region calculating position, UV and normals to add
        float distance, normalizedDistance;
        plane.Raycast(new Ray(positiveSideMeshTriangle.getVertices()[0], (negativeSideMeshTriangle.getVertices()[0] - positiveSideMeshTriangle.getVertices()[0]).normalized), out distance);
        
        normalizedDistance = distance / (negativeSideMeshTriangle.getVertices()[0] - positiveSideMeshTriangle.getVertices()[0]).magnitude;
        Vector3 vertexPositive = Vector3.Lerp(positiveSideMeshTriangle.getVertices()[0], negativeSideMeshTriangle.getVertices()[0], normalizedDistance);
        addedVertices.Add(vertexPositive);

        Vector3 normalPositive = Vector3.Lerp(positiveSideMeshTriangle.getNormals()[0], negativeSideMeshTriangle.getNormals()[0], normalizedDistance);
        Vector2 uvPositive = Vector2.Lerp(positiveSideMeshTriangle.getUvs()[0], negativeSideMeshTriangle.getUvs()[0], normalizedDistance);
        Vector2 rtLightmapUvsPositive = Vector2.Lerp(positiveSideMeshTriangle.getRtLightmapUvs()[0], negativeSideMeshTriangle.getRtLightmapUvs()[0], normalizedDistance);


        plane.Raycast(new Ray(positiveSideMeshTriangle.getVertices()[1], (negativeSideMeshTriangle.getVertices()[1] - positiveSideMeshTriangle.getVertices()[1]).normalized), out distance);

        normalizedDistance = distance / (negativeSideMeshTriangle.getVertices()[1] - positiveSideMeshTriangle.getVertices()[1]).magnitude;
        Vector3 vertexNegative = Vector3.Lerp(positiveSideMeshTriangle.getVertices()[1], negativeSideMeshTriangle.getVertices()[1], normalizedDistance);
        addedVertices.Add(vertexNegative);

        Vector3 normalNegative = Vector3.Lerp(positiveSideMeshTriangle.getNormals()[1], negativeSideMeshTriangle.getNormals()[1], normalizedDistance);
        Vector2 uvNegative = Vector2.Lerp(positiveSideMeshTriangle.getUvs()[1], negativeSideMeshTriangle.getUvs()[1], normalizedDistance);
        Vector2 rtLightmapUvsNegative = Vector2.Lerp(positiveSideMeshTriangle.getRtLightmapUvs()[1], negativeSideMeshTriangle.getRtLightmapUvs()[1], normalizedDistance);
        #endregion

        #region converting data to mesh triangles and adding it to the mesh if its not already part of it
        Vector3[] generatedVertices = new Vector3[] { positiveSideMeshTriangle.getVertices()[0], vertexPositive, vertexNegative };
        Vector3[] generatedNormals = new Vector3[] { positiveSideMeshTriangle.getNormals()[0], normalPositive, normalNegative };
        Vector2[] generatedUvs = new Vector2[] { positiveSideMeshTriangle.getUvs()[0], uvPositive, uvNegative };
        Vector2[] generatedRtLightmapUvs = new Vector2[] { positiveSideMeshTriangle.getRtLightmapUvs()[0], rtLightmapUvsPositive, rtLightmapUvsNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(positiveSide, generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, meshTriangle.getSubmeshIndex());

        generatedVertices = new Vector3[] { positiveSideMeshTriangle.getVertices()[0], positiveSideMeshTriangle.getVertices()[1], vertexNegative };
        generatedNormals = new Vector3[] { positiveSideMeshTriangle.getNormals()[0], positiveSideMeshTriangle.getNormals()[1], normalNegative };
        generatedUvs = new Vector2[] { positiveSideMeshTriangle.getUvs()[0], positiveSideMeshTriangle.getUvs()[1], uvNegative };
        generatedRtLightmapUvs = new Vector2[] { positiveSideMeshTriangle.getRtLightmapUvs()[0], positiveSideMeshTriangle.getRtLightmapUvs()[1], rtLightmapUvsNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(positiveSide, generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, meshTriangle.getSubmeshIndex()); ;

        generatedVertices = new Vector3[] { negativeSideMeshTriangle.getVertices()[0], vertexPositive, vertexNegative };
        generatedNormals = new Vector3[] { negativeSideMeshTriangle.getNormals()[0], normalPositive, normalNegative };
        generatedUvs = new Vector2[] { negativeSideMeshTriangle.getUvs()[0], uvPositive, uvNegative };
        generatedRtLightmapUvs = new Vector2[] { negativeSideMeshTriangle.getRtLightmapUvs()[0], rtLightmapUvsPositive, rtLightmapUvsNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(negativeSide, generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, meshTriangle.getSubmeshIndex());

        generatedVertices = new Vector3[] { negativeSideMeshTriangle.getVertices()[0], negativeSideMeshTriangle.getVertices()[1], vertexNegative };
        generatedNormals = new Vector3[] { negativeSideMeshTriangle.getNormals()[0], negativeSideMeshTriangle.getNormals()[1], normalNegative };
        generatedUvs = new Vector2[] { negativeSideMeshTriangle.getUvs()[0], negativeSideMeshTriangle.getUvs()[1], uvNegative };
        generatedRtLightmapUvs = new Vector2[] { negativeSideMeshTriangle.getRtLightmapUvs()[0], negativeSideMeshTriangle.getRtLightmapUvs()[1], rtLightmapUvsNegative };

        if (generatedVertices[0] != generatedVertices[1] && generatedVertices[0] != generatedVertices[2])
            addGeneratedTriangle(negativeSide, generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, meshTriangle.getSubmeshIndex());
        #endregion
    }

    //Function that adds a triangle to the parsed in meshToAdd, while flipping it if it looks the wrong way
    void addGeneratedTriangle(GeneratedMesh meshToAdd, Vector3[] generatedVertices, Vector3[] generatedNormals, Vector2[] generatedUvs, Vector2[] generatedRtLightmapUvs, int submeshIndex)
    {
        MeshTriangle generatedTriangle = new MeshTriangle(generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, submeshIndex);

        //Cross product = normal of two vertices, dot product
        //v * w > 0 == Vectors look at same side of plane || v * w < 0 == Vectors look at different of plane
        if (Vector3.Dot(Vector3.Cross(generatedVertices[1] - generatedVertices[0], generatedVertices[2] - generatedVertices[0]), generatedNormals[0]) < 0)
        {
            flipTriangle(generatedTriangle);
        }

        meshToAdd.addTriangle(generatedTriangle);
    }

    //Function switches the position of the first and last vertice, normal and uv with each other
    void flipTriangle(MeshTriangle meshTriangle)
    {
        List<Vector3> triangleVerticies = meshTriangle.getVertices();
        Vector3 lastVertex = triangleVerticies[triangleVerticies.Count-1];
        triangleVerticies[triangleVerticies.Count-1] = triangleVerticies[0];
        triangleVerticies[0] = lastVertex;


        List<Vector3> triangleNormals = meshTriangle.getNormals();
        Vector3 lastNormal = triangleNormals[triangleNormals.Count-1];
        triangleNormals[triangleNormals.Count-1] = triangleNormals[0];
        triangleNormals[0] = lastNormal;


        List<Vector2> triangleUvs = meshTriangle.getUvs();
        Vector2 lastUV = triangleUvs[triangleUvs.Count-1];
        triangleUvs[triangleUvs.Count-1] = triangleUvs[0];
        triangleUvs[0] = lastUV;

        List<Vector2> triangleRtLightmapUvs = meshTriangle.getRtLightmapUvs();
        Vector2 lastRtLightmapUvs = triangleRtLightmapUvs[triangleRtLightmapUvs.Count - 1];
        triangleRtLightmapUvs[triangleRtLightmapUvs.Count - 1] = triangleRtLightmapUvs[0];
        triangleRtLightmapUvs[0] = lastRtLightmapUvs;
    }

    #region Capping
    //Function that creates polygones out of all cut vertices using a helper function and then parses these polygons into the actual fill function
    void fillCut(List<Vector3> addedVertices, Plane plane, GeneratedMesh positiveMesh, GeneratedMesh negativeMesh) {
        List<Vector3> processedVertices = new List<Vector3>(), polygone = new List<Vector3>();

        for (int i=0; i<addedVertices.Count-1; i++) {           //-1 Custom Edit, trying to prevent OFB excepton
            if (!processedVertices.Contains(addedVertices[i])) {
                polygone = new List<Vector3>();
                polygone.Add(addedVertices[i]);
                polygone.Add(addedVertices[i+1]);          //OUT OF BOUNDS EXCEPTION here sometimes

                processedVertices.Add(addedVertices[i]);
                processedVertices.Add(addedVertices[i+1]);

                findConnectedVertices(addedVertices, processedVertices, polygone);
                fill(polygone, plane, positiveMesh, negativeMesh);
            }
        }
    }

    //Function that connects parsed in vertices by finding their middle point (like with an Orange). It then addes those newly created vertices to both sides of the cut Mesh
    void fill(List<Vector3> vertices, Plane plane, GeneratedMesh positiveMesh, GeneratedMesh negativeMesh)
    {
        //finding the center
        Vector3 center = new Vector3();
        for (int i = 0; i < vertices.Count; i++) {
            center += vertices[i];
        }
        center /= vertices.Count;
        
        Vector3 up = plane.normal;
        Vector3 left = new Vector3 (-up.y, up.x, 0);
        Vector3 forward = Quaternion.AngleAxis(90, up) * left;
        
        Vector3 displacement = new Vector3();
        Vector2 uv1, uv2;
        Vector2 rtLightmapUvs1, rtLightmapUvs2;

        for (int i = 0; i < vertices.Count; i++) {
            displacement = vertices[i] - center;
            uv1 = new Vector2(.5f + Vector3.Dot(displacement, left), .5f + Vector3.Dot(displacement, forward));
            rtLightmapUvs1 = new Vector2(.5f + Vector3.Dot(displacement, left), .5f + Vector3.Dot(displacement, forward));   //this generated a unprecise position on the Meshs surface. TODO

            //Debug.Log("vertex: " + vertices[i] + " displacement: " + displacement + " dot product left: " + Vector3.Dot(displacement, left) + " dot product forward: " + Vector3.Dot(displacement, forward));

            displacement = vertices[(i+1)%vertices.Count] - center;
            uv2 = new Vector2(.5f + Vector3.Dot(displacement, left), .5f + Vector3.Dot(displacement, forward));
            rtLightmapUvs2 = new Vector2(.5f + Vector3.Dot(displacement, left), .5f + Vector3.Dot(displacement, forward));

            Vector3[] generatedVertices = new Vector3[] {vertices[i], vertices[(i+1)%vertices.Count], center};
            Vector3[] generatedNormals = new Vector3[] {-up, -up, -up};
            Vector2[] generatedUvs = new Vector2[] { uv1, uv2, new Vector2(0.5f, 0.5f)};
            Vector2[] generatedRtLightmapUvs = new Vector2[] { rtLightmapUvs1, rtLightmapUvs2, new Vector2(0.5f, 0.5f) };

            //don't create different submesh layer if cutMaterial isn't set
            int submeshIndex = 0;

            //create it if it isn't
            if (cutMaterial != null)
            {
                if (!doesIncludeMaterial(gameObjectToCut.GetComponent<Renderer>().materials, cutMaterial))
                    submeshIndex = meshToCut.subMeshCount;
                else {
                    for (int j=0; j<gameObjectToCut.GetComponent<Renderer>().materials.Length; j++) {
                        if (compareMaterialNames(gameObjectToCut.GetComponent<Renderer>().materials[j], cutMaterial))
                            submeshIndex = j;
                    }
                }
            }

            addGeneratedTriangle(positiveMesh, generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, submeshIndex);

            generatedNormals = new Vector3[] {up, up, up};
            addGeneratedTriangle(negativeMesh, generatedVertices, generatedNormals, generatedUvs, generatedRtLightmapUvs, submeshIndex);
        }
    }

    //Function that creates polygones out of all cut vertices
    void findConnectedVertices(List<Vector3> addedVertices, List<Vector3> processedVertices, List<Vector3> polygone)
    {
        bool isDone = false;
        while (!isDone) {
            isDone = true;
            for (int i=0; i<addedVertices.Count; i+=2) {
                if (addedVertices[i] == polygone[polygone.Count-1] && !processedVertices.Contains(addedVertices[i+1]))
                {
                    isDone = false;
                    polygone.Add(addedVertices[i+1]);
                    processedVertices.Add(addedVertices[i+1]);
                }
                else if (addedVertices[i+1] == polygone[polygone.Count-1] && !processedVertices.Contains(addedVertices[i])) {
                    isDone = false;
                    polygone.Add(addedVertices[i]);
                    processedVertices.Add(addedVertices[i]);
                }
            }
        }
    }
    #endregion

    #region Mesh creation
    //Function that creates interactable gameObjects within the scene using the root Objects Data and the generated mesh data
    void createGameObject(GeneratedMesh newMeshData)
    {
        //if the colliders of a Mesh are bigger than the Mesh itself, so the Function was triggered but no triangle was cut
        if (newMeshData.getVertices().Count > 0)
        {
            //creating copy of the game Object that is getting cut
            GameObject cutGameObject = GameObject.Instantiate(gameObjectToCut, gameObjectToCut.transform.position, gameObjectToCut.transform.rotation);
            //only if a cutObjectContainer exists (like in the testing scene)
            if (GameObject.FindGameObjectWithTag(Tags.cutObjectContainer))
                cutGameObject.transform.SetParent(GameObject.FindGameObjectWithTag(Tags.cutObjectContainer).transform);
            else
                cutGameObject.transform.SetParent(gameObjectToCut.transform.parent);

            Mesh generatedMesh = cutGameObject.GetComponent<MeshFilter>().mesh;
            generatedMesh.Clear();

            //set new materials Array when a cut Material is to be added
            if (cutMaterial != null && cap) {
                Material[] materials;
                //adds cut Material to submesh layers if it isn't already part of it while copying all Materials that are part of the Mesh
                if (!doesIncludeMaterial(gameObjectToCut.GetComponent<Renderer>().materials, cutMaterial))
                {
                    generatedMesh.subMeshCount = meshToCut.subMeshCount + 1;

                    materials = new Material[cutGameObject.GetComponent<Renderer>().materials.Length + 1];

                    materials[materials.Length - 1] = cutMaterial;
                }
                //copies all Materials that are part of the Mesh
                else
                {
                    generatedMesh.subMeshCount = meshToCut.subMeshCount;

                    materials = new Material[cutGameObject.GetComponent<Renderer>().materials.Length];
                }
                for (int i = 0; i < cutGameObject.GetComponent<Renderer>().materials.Length; i++) {
                    materials[i] = cutGameObject.GetComponent<Renderer>().materials[i];
                }

                cutGameObject.GetComponent<Renderer>().materials = materials;
            }

            //writes all mesh Data into the mesh
            generatedMesh.vertices = newMeshData.getVertices().ToArray();
            generatedMesh.normals = newMeshData.getNormals().ToArray();
            generatedMesh.SetUVs(0, newMeshData.getUvs());
            generatedMesh.SetUVs(1, newMeshData.getRtLightmapUvs());

            for (int i = 0; i < newMeshData.getSubmeshIndices().Count; i++)
            {
                generatedMesh.SetTriangles(newMeshData.getSubmeshIndices()[i].ToArray(), i);
            }

            //generatedMesh.RecalculateNormals();
            generatedMesh.RecalculateTangents();    //this could potentially be slow. Maybe copy all tangens by hand    --> GENERATES TANGENS FOR NORMAL MAPS

            foreach (Collider col in cutGameObject.GetComponents<Collider>())
                GameObject.Destroy(col);
            
            //creates mesh Collider for Object
            MeshCollider meshCollider = cutGameObject.AddComponent<MeshCollider>();
            meshCollider.convex = true;
            meshCollider.sharedMesh = cutGameObject.GetComponent<MeshFilter>().mesh;
        }
    }

    //Function that finds seperated Meshes within one GeneratedMesh and initializes them all seperately
    void findSeperatedMeshes(GeneratedMesh meshToSeperate)
    {
        List<int> connectedVertexIndeces, leftoverVertexIndeces = new List<int>();

        int numberOfVertexIndeces = 0;

        foreach (List<int> vertexIndeces in meshToSeperate.getSubmeshIndices())
        {
            leftoverVertexIndeces.AddRange(vertexIndeces);
            numberOfVertexIndeces += vertexIndeces.Count;
        }
        
        while (leftoverVertexIndeces.Count > 0) {
            connectedVertexIndeces = new List<int>();
            int[] currentTriangle = new int[] { leftoverVertexIndeces[0], leftoverVertexIndeces[1], leftoverVertexIndeces[2]};

            leftoverVertexIndeces.RemoveRange(0, 3);

            //holds all Vertex Indeces that are connected with one another
            connectedVertexIndeces = getConnectedTriangles(currentTriangle, leftoverVertexIndeces, meshToSeperate);

            //if there's no seperation
            if (connectedVertexIndeces.Count == numberOfVertexIndeces)
            {
                createGameObject(meshToSeperate);
                break;
            }
            else
            {
                GeneratedMesh seperatedMesh = new GeneratedMesh();

                for (int i = 0; i < connectedVertexIndeces.Count; i += 3)
                {
                    //uses data in connectedVertexIndeces to copy all Mesh data into a new GeneratedMesh
                    Vector3[] vertices = new Vector3[3] {meshToSeperate.getVertices()[connectedVertexIndeces[i]],
                        meshToSeperate.getVertices()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getVertices()[connectedVertexIndeces[i+2]]};
                    Vector3[] normals = new Vector3[3] {meshToSeperate.getNormals()[connectedVertexIndeces[i]],
                        meshToSeperate.getNormals()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getNormals()[connectedVertexIndeces[i+2]]};
                    Vector2[] Uvs = new Vector2[3] {meshToSeperate.getUvs()[connectedVertexIndeces[i]],
                        meshToSeperate.getUvs()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getUvs()[connectedVertexIndeces[i+2]]}; 
                    Vector2[] rtLightmapUvs = new Vector2[3] {meshToSeperate.getRtLightmapUvs()[connectedVertexIndeces[i]],
                        meshToSeperate.getRtLightmapUvs()[connectedVertexIndeces[i+1]],
                        meshToSeperate.getRtLightmapUvs()[connectedVertexIndeces[i+2]]};

                    int submeshIndex = 0;
                    if (meshToSeperate.getSubmeshIndices().Count > 1) {
                        //Parses all submeshes of mesh until it finds the one holding our verteces
                        for (int j = 0; j < meshToSeperate.getSubmeshIndices().Count; j++) {
                            if (meshToSeperate.getSubmeshIndices()[j].Contains(connectedVertexIndeces[i]) &&
                                meshToSeperate.getSubmeshIndices()[j].Contains(connectedVertexIndeces[i+1]) &&
                                meshToSeperate.getSubmeshIndices()[j].Contains(connectedVertexIndeces[i+2]))
                            {
                                submeshIndex = j;
                                break;
                            }
                        }
                    }

                    MeshTriangle meshTriangle = new MeshTriangle(vertices, normals, Uvs, rtLightmapUvs, submeshIndex);

                    seperatedMesh.addTriangle(meshTriangle);

                    leftoverVertexIndeces.Remove(connectedVertexIndeces[i]);
                    leftoverVertexIndeces.Remove(connectedVertexIndeces[i+1]);
                    leftoverVertexIndeces.Remove(connectedVertexIndeces[i+2]);
                }

                createGameObject(seperatedMesh);
            }
        }
    }

    //Function that finds all connected vertex Indeces recursively for a picked Triangle
    public List<int> getConnectedTriangles(int[] pickedTriangle, List<int> vertexIndeces, GeneratedMesh meshToSeperate)
    {
        List<int> result = new List<int>(pickedTriangle), neighbors = new List<int>(), indecesOfIndecesToRemove = new List<int>();

        // Finding all neigbor Triangles
        for (int i = 0; i < vertexIndeces.Count; i += 3)
        {
            int[] currentTriangle = new int[3] {vertexIndeces[i], vertexIndeces[i + 1], vertexIndeces[i + 2]};
            
            // Check if Triangles share common Edge
            if (isConnected(convertIndecesToVerteces(currentTriangle, meshToSeperate), convertIndecesToVerteces(pickedTriangle, meshToSeperate)))
            {
                neighbors.AddRange(currentTriangle);

                indecesOfIndecesToRemove.Add(i);
                indecesOfIndecesToRemove.Add(i+1);
                indecesOfIndecesToRemove.Add(i+2);

                //performance boost: cancel this operation when neighbors length is 3 in first call and 2 in every single other call
            }
        }

        //remove all already connected Trinagles out of the vertexIndeces List
        for (int i = indecesOfIndecesToRemove.Count-1; i >= 0; i--)
        {
            vertexIndeces.RemoveAt(indecesOfIndecesToRemove[i]);
        }

        //recall this function recursively to find all existing neighbors
        for (int i = 0; i < neighbors.Count; i += 3)
        {
            int[] currentTriangle = new int[3] { neighbors[i], neighbors[i + 1], neighbors[i + 2] };
            
            // Recursively add all the linked faces to the result
            result.AddRange(getConnectedTriangles(currentTriangle, vertexIndeces, meshToSeperate));
        }
        
        return result;
    }
    
    //Function that checks if the Edges of two Verteces are similar to one another
    bool isConnected(Vector3[] triangleA, Vector3[] triangleB)
    {
        for (int i = 0; i < triangleA.Length; i++)
            for (int j = 0; j < triangleB.Length; j++)
                if (triangleA[i] == triangleB[j] &&
                    ((triangleA[(i + 1) % 3] == triangleB[(j + 1) % 3] || triangleA[(i + 1) % 3] == triangleB[(j + 2) % 3]) ||
                    (triangleA[(i + 2) % 3] == triangleB[(j + 1) % 3] || triangleA[(i + 2) % 3] == triangleB[(j + 2) % 3])))
                    return true;

        return false;
    }
    
    //Function that converts vertex Indeces into their respective Vertex
    Vector3[] convertIndecesToVerteces(int[] vertexIndices, GeneratedMesh meshData)
    {
        Vector3[] vecs = new Vector3[vertexIndices.Length];

        for (int i = 0; i < vecs.Length; i++) {
            vecs[i] = meshData.getVertices()[vertexIndices[i]];
        }

        return vecs;
    }

    //returns if list of material Instances does include root material
    bool doesIncludeMaterial(Material[] materials, Material material) {
        foreach (Material mat in materials)
        {
            if (compareMaterialNames(mat, material))
                return true;
        }

        return false;
    }

    //checking if names are similar and then again by removing excess name on both sides: E.g. (Instance) tag
    bool compareMaterialNames(Material materialA, Material materialB)
    {
        if (materialA.name == materialB.name)
            return true;
        
        if (materialA.name.Length > materialB.name.Length && materialA.name.Substring(0, materialB.name.Length) == materialB.name)
            return true;
        
        if (materialA.name.Length < materialB.name.Length && materialB.name.Substring(0, materialA.name.Length) == materialA.name)
            return true;

        return false;
    }
    #endregion
}
